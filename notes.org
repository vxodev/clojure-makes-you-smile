
* ( Clojure )

* ( about Me )

(Nästan) examinerad naturgeograf.

Brinner för systemutveckling och problemlösning. 

* ( why Clojure )

Lisp exercerar nya kopplingar i hjärnan. Andra språk är ganska like varandra. Clojure "sticker ut".

Lite som Texas Hold'em - "Takes an hour to learn and a life-time to master"

Framför allt - för mig personligen:

Samma kick jag fick när jag upptäckte Ruby efter ett antal år med Java och C++ - den får jag från Clojure.

Förhoppningsvis kan jag få fler att upptäcka Clojure. 

Det tog mig ett par försök att bli "hooked". Syntaxen skrämde bort mig, och jag var fortfarande fast i OO - kunde inte riktigt släppa det.

Tips: skifta mindset från OO till FP - en bra artikel:

http://steve-yegge.blogspot.se/2006/03/execution-in-kingdom-of-nouns.html

* ( what makes clojure Great? )

Saker som vi ska snacka om.

Saker som jag tycker gör att Clojure särskiljer sig från andra språk.

* ( what is Clojure? )

- Functional
- Dynamically typed language
  - ~clojure.spec~ - contract-driven
- Ägnade 2.5 år åt att värka fram Clojure (med egna medel).
- Nalle Puh: Tänk tänk tänk

* ( LISP - Lots if irritating superflous parentheses )

- "Hittade"?
  - Ursprungligen en matematisk notation för datorer (lambda calculus, Alonso Church)
- Vad särskiljer Lisp från andra språk.
  - Med en liten uppsättning grundfunktioner och datastrukturer så kan man definiera upp resten av språket.
  - First language (well, there was only Fortran before..) with conditionals, first-class functions, recursion, garbage-collection, trees of expressions, read-eval-print loop.
  - Code is data: Enter macros. The abstraction level is Lisp in a much larger portion than in any other language.

* ( rich Hickey )

Mannen bakom Clojure.

Väldigt konsekvent och analytisk. Säger han något om en lösning så har han tänkt igenom den.

* ( rich hickey Essentials )

Fantastiskt många bra videos. Dessa tre speciellt

- Simple Made Easy
  - Uncomplecting things
  - Simple programs work
- Hammock-driven Development
  - *Think* about a problem
  - Agile is nice, but we're solving problems - don't forget to identify and understand the problem.
- Are we there yet
  - About 'accidental complexity', values and time
  - OO vs data-driven FP

* ( clojure Philosophy )

- Simplicity: Meaning - do one thing. Do not complect unrelated things.
- State vs. Values.

- In OO: Everything is a typed class. How do you reuse and compose functions on those types?

* ( clojure.tour )


Looks intimidating!
Scary!

Relax. 

* ( clojure.tour/data-types )

Dina vanliga datatyper. Med vissa undantag - symboler är en dedikerad datatyp.

* ( clojure.tour/syntax )

Basic expressions

Everyting evaluates to something.

Ingen komplicerad operator-precedence - alla uttryck evalueras innifrån och ut.

Konsistent syntax (fast det kan ta en stund att vänja sig vid)

* ( clojure.tour/vars )

Inte "vars" i den egentliga meningen. Det är en namngivning av ett värde.

* ( clojure.tour/data-types collections )

De flesta funktioner returnerar 'lazy' collections. Dvs - de evalueras inte förrän man börjar konsumera dem.

Det finns 'sets' också. Alla collections i Clojure implementerar ett ~ISeq~ protokoll mot vilket i princip alla collection-funktioner är skrivna (få typer - många funktioner)

* ( clojure.tour/data-types maps )

Bread and butter of clojure.

* ( clojure.tour/functions )

Functions are first-class values. So just bind them to a var.

Defn macro - not really a macro, but it behaves as one.

* ( clojure.tour/higher-order-functions )

HOF - tar eller returnerar funktioner.

De vanliga FP-abstraktionerna ( flatMap -> mapcat )

* ( clojure.tour/composing-higher-order-functions )

Hur sitter det ihop? 

* ( immutability )

(Almost) everything in Clojure is a value. (Almost) every data-type is
immutable.

Resource-usage? If nothing is mutated - how can write efficient programs?
Persistent Data Structures

Sharing data is not a problem anymore! 

Detta förändrar sättet man strukturerar sin lösning. Don't be afraid of the *values*.

* ( explicit State in Clojure )

I Clojure modifierar man inte state för ett "objekt".
Man definierar en _plats_ där global state can uppdateras. Eller rättare sagt - där current state finns.

I Clojure är mutering *explicit* och görs i tydligt deklarerade zoner.

STM - Software Transactional memory

* ( code is Data )

Macros - core feature of Lisps. 

I de flesta andra språk är syntaxen något som är lagt ovanpå själva implementationen. I LISPs är normalt en väldigt stor del av språket implementerat i, well, LISP.

Det ger helt andra möjligheter att anpassa språket till *ditt* behov.

För att t.ex. extenda Ruby eller Java krävs det att man hackar C.

Thanks to the read-eval-print loop (REPL) everything can be changed.

Great for writing DSLs. Great for 

- TODO: Example
- Infix
- Show example from Clojure code
- Threading macro

* ( polymorphism a la Carte )

Protocols
Multimethods
Records

* ( java Interop )

- Create and interact with Java classes/objects
- Implement interfaces / extend classes
- Interacting with Java from Clojure can actually result in *fewer* parentheses..

* ( clojureScript )

Killer feature. Full stack. Ship libraries for both JVM and Javascript.
Share code. Share data. 

Growing - recently a Clojurescript compiler in Javascript (no JVM dep).

- I hear it's great! A bunch of frameworks that builds on top of React (Om, Reagent)
- Merges well with Clojure's way to handle state (an atom)
- Compiles Javascript using Googles Closure compiler
- https://clojurescript.org/
- Full stack language. Immutable datastructures all the way.

* ( clojure Community \hearts )

  - Very open community
  - Creative (Inventing stuff) and a bit artsy
    - Quil and Overtone
    - Check out http://overtone.github.io/ and http://quil.info/
    - Very inclusive
  - Clojure Remote
    
* ( developer Experience )

- Developer Experience
  - The REPL
  - Thinking inside-out.
    
* ( getting Started )
http://www.braveclojure.com/
* ( end )

* NOTES


- Intro (Heading)
- About me
  - Java (everything.. EJB 1.0, JSTL, JSF, WebWork, Actors)
  - Ruby, Scala, Haskell
  - Messed around with: Python, Erlang, Javascript, Elm etc.
- Why did I start with Clojure?
- What makes Clojure special (for me)?
  - Agenda
  - Same warm feeling that I got when discovering Ruby ~2001.
  - Writing Clojure makes me happy. Forces me to think in new ways.
    - Even if I don't use it at work - it affects the way I code in Java as well.
- It's a LISP
  - And it's invented by Rich Hickey :-)
  - Mentality
- Immutability
  - Why mutability bad?
  - Instant Clojure
    - Datatypes
  - Persistent data structures
- Mutability
  - Wait, what?!
  - Things need to change, but in Clojure it's *explicit*
- Clojurescript
  - I hear it's great! A bunch of frameworks that builds on top of React (Om, Reagent)
  - Merges well with Clojure's way to handle state (an atom)
  - Compiles Javascript using Googles Closure compiler
  - https://clojurescript.org/
  - Full stack language. Immutable datastructures all the way.
- Polymorphism a la Carte
  - Protocol
  - Multi-methods
- Java interop
- Community \hearts
  - Very open community
  - Creative (Inventing stuff) and a bit artsy
    - Quil and Overtone
    - Check out http://overtone.github.io/ and http://quil.info/
    - Very inclusive
- Developer Experience
  - The REPL
  - Thinking inside-out.
- Some live coding (maybe, not sure I can do that)
- Learn one new language each year. Learn Clojure in 2017 :-)
- How to get started?
  - Install Leiningen
  - Editors
    - Emacs, VIM, Cursive (IntelliJ), Nightcode
  - http://www.4clojure.com/
  - Codewars (https://www.codewars.com/)

- Reading:
  - http://nathanmarz.com/blog/clojure-or-how-i-learned-to-stop-worrying-and-love-the-paren.html
    - "Clojure prefers immutable data and forces the programmer to be explicit about manipulating state. Clojure makes explicit the difference between a value (an immutable piece of data) and an identity (an entity whose value changes over time)."
    - Simple - untangled - avoid complex (as in braided) code.
  - https://www.quora.com/Why-would-someone-learn-Clojure
    - JVM-based. Rich selection of libraries.
    - It's a LISP: http://www.paulgraham.com/diff.html
      - First language (well, there was only Fortran before..) with conditionals, first-class functions, recursion, garbage-collection, trees of expressions, read-eval-print loop.
      - Code is data: Enter macros. The abstraction level is Lisp in a much larger portion than in any other language.
      - Concurrency: side-effects, STM
  - https://medium.com/@maleghast/why-i-love-clojure-a96847401fb1
    - The REPL changes how you develop code.
    - Fun!
    - The functional paradigms are clear.
    - Ecosystem for integration with Java libraries is hugh.
    - The same excitement and joy as when discovering Ruby after spending 5 years in Java-land
  - http://steve-yegge.blogspot.se/2006/03/execution-in-kingdom-of-nouns.html
    - A good essay about the different way of looking at problems in strict OO vs FP.
  - http://blog.venanti.us/why-clojure/
    - Many ppl have bad experiences of Lisp from University
    - Again, the REPL
    - Macros
    
