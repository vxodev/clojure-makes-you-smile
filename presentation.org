* ( Clojure )

[[file:pics/lisp_cycles.png]]

https://github.com/vxodev/clojure-makes-you-smile

* ( about Me )

- Gears of Leo
  - HRM Software, 2013
    - Boss Media, 2008
      - Epireal, 2005
        - WM-data, 1999
          - Lund
          
- Java (done it all...)
- Ruby (2001)
- Scala, Haskell, Python, Erlang, Javascript ...

* ( why Clojure )

[[file:pics/lisp.jpg]]

( LISP is good for you )\trade

* ( what makes clojure Great? )

- Rich Hickey!
- Immutability
- Explicit State
- Code is data
- Java interop
- Clojurescript
- The community
- Developer experience (warm and fuzzy feeling)

* ( what is Clojure? )

[[file:pics/clojure.png]]

- En LISP på JVM:en, CLR och Javascript
- Funktionellt språk
- Skapades av Rich Hickey. Första releasen 2009

* ( LISP - Lots if irritating superflous parentheses )

[[file:pics/McCarthy.jpg]]

John McCarthy - "Hittade" LISP 1958.

* ( rich Hickey )

[[file:pics/fakerichhickey.jpg]]

https://github.com/tallesl/Rich-Hickey-fanclub

* ( rich hickey Essentials )

** Simple made easy

https://www.youtube.com/watch?v=rI8tNMsozo0

** Hammock-driven development

https://www.youtube.com/watch?v=f84n5oFoZBc

** Are we there yet?

https://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey

* ( clojure Philosophy )

#+BEGIN_QUOTE
"It is better to have 100 functions operate on one data structure than 10
functions on 10 data structures." 
-- Alan Perlis
#+END_QUOTE

#+BEGIN_QUOTE
"Simplicity is prerequisite for reliability." 
-- Edsger Dijkstra
#+END_QUOTE

* ( clojure.tour )

WELP! 

#+BEGIN_SRC clojure
  (defn sum-of-range
    [start end]
    (let [count (inc (- end start))]
      (/ (* (+ start end) count) 2)))

  (defn end-seq "A seq of start values per week"
    [n] (iterate inc n))
  (defn start-seq "A seq of end values per week"
    [n] (iterate (partial + 2) 0))
  (defn start-and-ends "A lazy seq of starts and ends of weeks"
    [n] (map vector (start-seq n) (end-seq n)))

  (defn finance
    [n]
    ;; Calculate the total sum
    (reduce + 0
            ;; Map to the sum of that week
            (map #(apply sum-of-range %)
                 ;; All start-end pairs of n
                 (take (inc n) (start-and-ends n)))))
#+END_SRC

* ( clojure.tour/data-types )

| TYPE       | SAMPLE  |
|------------+---------+
| string     | "foo"   |
| charachter | \f      |
| regex      | #"fo*"  |
| integer    | 42      |
| double     | 3.14159 |
| boolean    | true    |
| nil        | nil     |
| symbol     | foo, +  |
| keyword    | :foo    |

* ( clojure.tour/syntax )

#+BEGIN_SRC clojure
;; An expression is always of the form (fn arg1 arg2 ...)
(inc 2)
;; 3

(println "Hello")
;; <prints 'Hello' to stdout

(+ 1 1)
;; 2

;; Evaluation order - inner expressions are always evaluated first

(+ 1 (* 4 5))
;; 21
#+END_SRC

* ( clojure.tour/data-types collections )

#+BEGIN_SRC clojure
;; Vector
[1 4 6]

;; List
'(1 4 6)

;; Difference?
(conj [1 4 6] 8)
;; [1 4 6 8]
(conj '(1 4 6) 8)
;; (8 1 4 6)
#+END_SRC

* ( clojure.tour/data-types maps )

#+BEGIN_SRC clojure
  (def record {:album "Blunderbuss"
               :artist "Jack White"
               :released 2013})

  (get record :artist)
  ;; "Jack White"

  (:album record)
  ;; "Blunderbuss"

  (assoc record :tracks 13)
  ;; {:album "Blunderbuss" :artist "Jack White" :released 2013 :tracks 13}

  (update record :released inc)
  ;; {:album "Blunderbuss" :artist "Jack White" :released 2014 :tracks 13}

#+END_SRC

* ( clojure.tour/functions )

#+BEGIN_SRC clojure
  ;; Anonymous function
  (fn [n] (+ 1 n))

  ;; Or - shorter:
  #(+ 1 %)

  ;; Not that useful:
  ((fn [n] #(+ 1 %)) 3)
  ;; 4

  ;; Bind to a symbol
  (def add-one (fn [n] (+ 1 n)))

  (add-one 3)
  ;; 4

  ;; defn-macro
  (defn add-one [n] (+ n 1))

  (add-one 3)
  ;; 4
#+END_SRC

* ( clojure.tour/higher-order-functions )

** Map

#+BEGIN_SRC clojure
(def coll ["a" "bbb" "cccc"])

(map #(count %) coll)
;; (1 3 4)

;; Or shorter
(map count coll)
#+END_SRC

** Filter

#+BEGIN_SRC clojure
  (def coll [1 2 3 4])

  (filter odd? coll)
  ;; (1 3)
#+END_SRC

** Reduce

#+BEGIN_SRC clojure
  (def numbers [1 2 3 4 5])

  (reduce + 0 numbers)
  ;; 15
#+END_SRC

* ( immutability )

#+BEGIN_QUOTE
"Mutable shared state is the root to all evil" 
-- Dale Schumacher
#+END_QUOTE

- "In what state is my object?"
- "When did it change? Who changed it?"
- Add threads: Mayhem!

* ( explicit State in Clojure )



* ( code is Data )

No likey prefix notation?

#+BEGIN_SRC clojure
  (+ 1 1)
  ;; 2

  (concat [1 2 3] [4 5 6])
  ;; (1 2 3 4 5 6)

  (defmacro infix
    "Allows you to call a fn with two args as '(arg1 fn arg2)'"
    [infixed] (list (second infixed) (first infixed) (last infixed)))

  (infix (1 + 1))
  ;; 2

  (infix ([1 2 3] concat [4 5 6]))
  ;; (1 2 3 4 5 6)
#+END_SRC

Thread macro

#+BEGIN_SRC clojure
  (-> 2
      (inc)
      (repeat :a))
  ;; (:a :a :a)

  (source ->)
  ;; (defmacro ->
  ;;   "Threads the expr through the forms. Inserts x as the
  ;;   second item in the first form, making a list of it if it is not a
  ;;   list already. If there are more forms, inserts the first form as the
  ;;   second item in second form, etc."
  ;;   {:added "1.0"}
  ;;   [x & forms]
  ;;   (loop [x x, forms forms]
  ;;     (if forms
  ;;       (let [form (first forms)
  ;;             threaded (if (seq? form)
  ;;                        (with-meta `(~(first form) ~x ~@(next form)) (meta form))
  ;;                        (list form x))]
  ;;         (recur threaded (next forms)))
  ;;       x)))

  (macroexpand '(2 (inc) (repeat :a)))
  ;; (2 (inc) (repeat :a))


#+END_SRC

* ( polymorphism a la Carte )

* ( java Interop )



* ( clojureScript )

* ( clojure Community \hearts )

* ( developer Experience )

* ( getting Started )

- [[http://steve-yegge.blogspot.se/2006/03/execution-in-kingdom-of-nouns.html][Execution in the kingdom of Nouns]]

* ( end )

#+BEGIN_QUOTE
"Learn one new language each year."
-- Pragmatic Programmer
#+END_QUOTE

Learn Clojure 2017!

